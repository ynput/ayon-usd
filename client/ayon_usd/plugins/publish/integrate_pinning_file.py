"""Extract pinning file from USD file as a json file.

This is WIP and will be refactored in the future.
"""
from __future__ import annotations

import json
import logging
import os
import re
from pathlib import Path
from typing import TYPE_CHECKING, Any, ClassVar, Optional, Union
from urllib.parse import urlparse

import ayon_api
import pyblish.api
from ayon_core.lib import StringTemplate, TemplateUnsolved
from ayon_core.pipeline import (
    Anatomy,
    OptionalPyblishPluginMixin,
    get_current_project_name,
)
from ayon_core.pipeline.publish import KnownPublishError
from pxr import Ar, Sdf, UsdShade

if TYPE_CHECKING:
    from ayon_core.lib.path_templates import TemplateResult

log = logging.getLogger("ayon_usd")


def is_uri(path: str) -> bool:
    """Check if a given path is a URI.

    Args:
        path (str): Path to check.

    Returns:
        bool: True if the path is a URI, False otherwise.

    """
    parsed = urlparse(path)
    return bool(parsed.scheme)


def remove_root_from_dependency_info(
        dependency_info: dict[str, str],
        root_info: dict[str, str]) -> dict[str, str]:
    """Re-roots a path dict.

    Ayon_Usd_Resolver can use its own system for root replace to
    resolve a given path.

    Args:
        dependency_info: dict generated by `get_asset_dependencies()`
        root_info: a flat dict containing
            str: root identifier {root[work]},
            str: associated root path /path/to/root

    Returns:
        The input dependency_info dict with replaced root_info to
        obtain root-less paths.

    """
    if not root_info or not dependency_info:
        return {}

    replacements = {
        re.escape(path_portion): replacer
        for replacer, path_portion in root_info.items()
    }

    pattern = re.compile("|".join(f"({pat})" for pat in replacements))

    def _replace_match(match: re.Match) -> str:
        """Replace the matched group with the corresponding root identifier."""
        for _, group in enumerate(match.groups(), start=1):
            if group:
                return "{root[" + replacements[re.escape(group)] + "]}"
        return match[0]

    root_less_dict = {}

    for key, path in dependency_info.items():
        new_path = pattern.sub(_replace_match, path)
        root_less_dict[key] = new_path

    return root_less_dict


def _get_prim_prop_data(prim: Sdf.PrimSpec, layer: Sdf.Layer) -> list[str]:
    prop_data = []
    for prop in prim.properties:
        if not isinstance(prop, Sdf.AttributeSpec):
            continue

        if prop.typeName != Sdf.ValueTypeNames.Asset:
            continue

        if default_val := prop.default:
            if hasattr(default_val, "__iter__"):
                prop_data.extend(default_val)
            else:
                prop_data.append(default_val.path)
        else:
            time_samples = layer.ListTimeSamplesForPath(prop.path)
            for time in time_samples:
                value = layer.QueryTimeSample(prop.path, time)
                prop_data.append(value.path)

    return prop_data


def _get_prim_spec_hierarchy_external_refs(
        prim: Sdf.PrimSpec,
        layer: Sdf.Layer) -> list[str]:
    """Recursively traverse the prim spec hierarchy.

    Returns all external references.

    Args:
        prim: The root prim spec.
        layer: The layer the prim spec belongs to.

    Returns:
        list[str]: List of external references.

    """
    file_list: list[str] = _get_prim_prop_data(prim, layer)

    for child_prim in prim.nameChildren:
        file_list.extend(
            _get_prim_spec_hierarchy_external_refs(
                child_prim, layer))
    return file_list


def _remove_sdf_args(ref: str) -> str:
    return re.sub(re.compile(r":SDF_FORMAT_ARGS.*$"), "", ref)


def _resolve(
        ref: str, layer_path: str, resolver: Ar.Resolver) -> Ar.ResolvedPath:
    if Path(ref).is_absolute() or is_uri(ref):
        return resolver.Resolve(ref)
    parent_file_dir_name = os.path.dirname(layer_path)
    abs_path = os.path.normpath(os.path.join(parent_file_dir_name, ref))
    return resolver.Resolve(abs_path)


def _resolve_udim(
        udim_identifier: str,
        layer: Sdf.Layer) -> dict[str, str]:
    udim_data = {}
    udim_regx = re.compile(r"<UDIM>")
    resolved_udims = UsdShade.UdimUtils.ResolveUdimTilePaths(
        udim_identifier, layer,
    )

    for resolved_udim_path in resolved_udims:
        udim_replaced_identifier = re.sub(
            udim_regx,
            resolved_udim_path[1],
            udim_identifier,
        )
        udim_data[udim_replaced_identifier] = resolved_udim_path[0]
    return udim_data


# TODO (Lypsolon): refactor so that this function has a gather block and a write
#   block currently all individual blocks write to the identifier_to_path_dict
#   and that makes sanitizing the data hard.
def get_asset_dependencies(
        layer_path: str,
        resolver: Ar.Resolver) -> dict[str, str]:
    """Recursively traverse Usd layers.

    Get all external asset dependency's as key value pair.

    Args:
        layer_path: Usd layer path to be taken as the root layer.
        resolver: Ar.Resolver object to resolve the asset paths.

    Returns:
        key: value pair dict that maps to asset identifier: resolved path

    """
    layer_path = _remove_sdf_args(layer_path)
    if not layer_path:
        return {}
    if isinstance(layer_path, Ar.ResolvedPath):
        layer_path = layer_path.GetPathString()

    resolved_layer_path = resolver.Resolve(layer_path)

    layer = Sdf.Layer.FindOrOpen(resolved_layer_path)
    if not layer:
        log.warning("Could not open layer %s", resolved_layer_path)
        return {}

    identifier_to_path_dict = {layer_path: resolved_layer_path.GetPathString()}
    prim_spec_file_paths = _get_prim_spec_hierarchy_external_refs(
        layer.pseudoRoot, layer,
    )
    for prim_spec in prim_spec_file_paths:
        prim_spec = str(prim_spec)  # noqa: PLW2901
        if "<UDIM>" in prim_spec:

            prim_spec = _remove_sdf_args(prim_spec)
            unresolved_udim_path = _resolve(
                prim_spec, layer.realPath, resolver)
            identifier_to_path_dict[prim_spec] = \
                unresolved_udim_path.GetPathString()

            udim_data = _resolve_udim(prim_spec, layer)
            identifier_to_path_dict |= udim_data
            continue

        prim_spec = _remove_sdf_args(prim_spec)
        identifier_to_path_dict[prim_spec] = _resolve(
            prim_spec, layer.realPath, resolver,
        )
    asset_identifier_list = layer.GetCompositionAssetDependencies()
    for ref in asset_identifier_list:
        if not ref:
            continue
        resolved_path = _resolve(
            ref, resolved_layer_path.GetPathString(), resolver)

        ref = _remove_sdf_args(ref)
        identifier_to_path_dict[ref] = resolved_path.GetPathString()

        recursive_result = get_asset_dependencies(
            resolved_path.GetPathString(), resolver,
        )
        identifier_to_path_dict |= recursive_result

    return identifier_to_path_dict


def write_pinning_file(
    output_path: str,
    pinning_data: dict[str, str],
) -> bool:
    """Write out a pinning file to disk in the appropriate format.

    Args:
        output_path: str path where the pinning file should be written to
        pinning_data: str the pinning dict that holds all the pinning data

    Returns: bool Ture on successful write

    """
    # data validation
    if not isinstance(pinning_data, dict):
        log.error("pinning data is not a dict")
        return False

    if not output_path.endswith(".json"):
        log.error("output_path is not a json")
        return False

    # file creation
    data = {"ayon_resolver_pinning_data": pinning_data}

    if Path(output_path).exists():
        with open(output_path) as pinning_file:
            existing_data = json.load(pinning_file)
            if existing_data.get("timestamp"):
                data["timestamp"] = existing_data["timestamp"]
            existing_data["ayon_resolver_pinning_data"] = pinning_data

    with open(output_path, "w") as pinning_file:
        json.dump(data, pinning_file, indent=2)
    return True


def generate_pinning_file(
    entry_usd: str,
    root_info: dict[str, str],
    pinning_file_path: str,
) -> None:
    """Generate a pinning file for a given USD file.

    Args:
        entry_usd: str path to the entry usd file
        root_info: dict[str, str] root identifier to root path
        pinning_file_path: str path to the pinning file

    """
    if not pinning_file_path.endswith(".json"):
        msg = f"Pinning file path is not a json file {pinning_file_path}"
        raise RuntimeError(msg)

    # Assume that the environment sets up the correct default AyonUsdResolver
    resolver = Ar.GetResolver()
    pinning_data = get_asset_dependencies(entry_usd, resolver)

    root_less_pinning_file_data = remove_root_from_dependency_info(
        pinning_data, root_info,
    )

    root_less_pinning_file_data["ayon_pinning_data_entry_scene"] = \
        _remove_sdf_args(entry_usd)
    write_pinning_file(
        pinning_file_path,
        root_less_pinning_file_data,
    )

    log.debug("Generated pinning file at %s", pinning_file_path)


# The following code from this point to </dup> is from:
# ayon_core/client/ayon_core/plugins/publish/extract_usd_layer_contributions.py
def _fix_representation_context_compatibility(repre_context: dict) -> None:
    """Fix representation context compatibility.

    Args:
        repre_context (dict): Representation context.

    """
    # Auto-fix 'udim' being list of integers
    # - This is a legacy issue for old representation entities,
    #   added 24/07/10
    udim = repre_context.get("udim")
    if isinstance(udim, list):
        repre_context["udim"] = udim[0]


def get_representation_path_with_anatomy(
        repre_entity: dict[str, Any],
        anatomy: Anatomy) -> Union[None, TemplateResult]:    # noqa: UP007
    """Receive representation path using representation document and anatomy.

    Anatomy is used to replace 'root' key in representation file. Ideally
    should be used instead of 'get_representation_path' which is based on
    "current context".

    Future notes:
        We want also be able store resources into representation and I can
        imagine the result should also contain paths to possible resources.

    Args:
        repre_entity (Dict[str, Any]): Representation entity.
        anatomy (Anatomy): Project anatomy object.

    Returns:
        Union[None, TemplateResult]: None if path can't be received

    Raises:
        InvalidRepresentationContext: When representation data are probably
            invalid or not available.

    """
    try:
        template = repre_entity["attrib"]["template"]

    except KeyError as e:
        msg = (
                "Representation document does not"
                " contain template in data ('data.template')"
        )
        raise ValueError(msg) from e

    try:
        context = repre_entity["context"]
        _fix_representation_context_compatibility(context)
        context["root"] = anatomy.roots

        path = StringTemplate.format_strict_template(template, context)

    except TemplateUnsolved as exc:
        errmsg = (
            "Couldn't resolve representation template"
            f"with available data. Reason: {exc}"
        )
        exc.args += (errmsg,)
        raise

    return path.normalized()


def get_representation_by_names(
        project_name: str,
        folder_path: str,
        product_name: str,
        version_name: Union[int, str],  # noqa: UP007
        representation_name: str,
) -> Optional[dict]:  # noqa: UP007
    """Get representation entity for asset and subset.

    If version_name is "hero" then return the hero version
    If version_name is "latest" then return the latest version
    Otherwise use version_name as the exact integer version name.

    """
    if isinstance(folder_path, dict) and "name" in folder_path:
        # Allow explicitly passing asset document
        folder_entity = folder_path
    else:
        folder_entity = ayon_api.get_folder_by_path(
            project_name, folder_path, fields=["id"])
    if not folder_entity:
        return {}

    if isinstance(product_name, dict) and "name" in product_name:
        # Allow explicitly passing subset document
        product_entity = product_name
    else:
        product_entity = ayon_api.get_product_by_name(
            project_name,
            product_name,
            folder_id=folder_entity["id"],
            fields=["id"])
    if not product_entity:
        return {}

    if version_name == "hero":
        version_entity = ayon_api.get_hero_version_by_product_id(
            project_name, product_id=product_entity["id"])
    elif version_name == "latest":
        version_entity = ayon_api.get_last_version_by_product_id(
            project_name, product_id=product_entity["id"])
    else:
        version_entity = ayon_api.get_version_by_name(
            project_name, version_name, product_id=product_entity["id"])
    if not version_entity:
        return {}

    return ayon_api.get_representation_by_name(
        project_name, representation_name, version_id=version_entity["id"])


def get_representation_path_by_names(  # noqa: PLR0913
        project_name: str,
        folder_path: str,
        product_name: str,
        version_name: str,
        representation_name: str,
        anatomy: Anatomy | None = None) -> str | None:
    """Get (latest) filepath for representation for folder and product.

    See `get_representation_by_names` for more details.

    Args:
        project_name (str): Project name.
        folder_path (str): Folder path.
        product_name (str): Product name.
        version_name (str): Version name.
        representation_name (str): Representation name.
        anatomy (Optional[Anatomy]): Anatomy object.

    Returns:
        str: The representation path if the representation exists.

    """
    representation = get_representation_by_names(
        project_name,
        folder_path,
        product_name,
        version_name,
        representation_name,
    )
    if not representation:
        return None

    if not anatomy:
        anatomy = Anatomy(project_name)

    if representation:
        path = get_representation_path_with_anatomy(representation, anatomy)
        return str(path).replace("\\", "/")
    return None


def get_last_publish(
        instance: pyblish.api.Instance,
        representation: str = "usd") -> str | None:
    """Get last representation publish path.

    Wrapper around `get_representation_path_by_names` to get the latest
    representation path for the instance.

    Args:
        instance (pyblish.api.Instance): Instance object.
        representation (str, optional): Representation name. Defaults to "usd".

    Returns:
        str | None: The representation path if the representation exists.

    """
    return get_representation_path_by_names(
        project_name=instance.context.data["projectName"],
        folder_path=instance.data["folderPath"],
        product_name=instance.data["productName"],
        version_name="latest",
        representation_name=representation
    )

# </dup> ------------------------


class IntegrateUsdPinningFile(pyblish.api.InstancePlugin,
                              OptionalPyblishPluginMixin):
    """Extract pinning file from USD file as a json file."""

    order = pyblish.api.IntegratorOrder + 0.01
    label = "Extract USD Pinning File"
    optional = True
    families: ClassVar = ["usd"]

    def process(self, instance: pyblish.api.Instance) -> None:
        global log  # this suxx but it's temporary
        log = self.log
        if not self.is_active(instance.data):
            return

        anatomy = instance.context.data["anatomy"]

        # get pinning json file
        if instance.data.get("versionEntity") is None:
            err_msg = "Instance was not integrated to AYON yet."
            raise KnownPublishError(err_msg)

        ayon_api.get_representation_by_name(
            get_current_project_name(),
            representation_name="usd_pinning",
            version_id=instance.data["version_entity"]["id"])

        published_repres = instance.data.get("published_representations")
        usd_file_rootless_path = None
        usd_pinning_rootless_file_path = None
        for rep in published_repres:
            if "usd" in rep["name"]:
                usd_file_rootless_path = rep["attrib"]["path"]
                continue
            if "usd_pinning" in rep["name"]:
                usd_pinning_rootless_file_path = rep["attrib"]["path"]
                continue

            if usd_file_rootless_path and usd_pinning_rootless_file_path:
                break

        if not usd_file_rootless_path or not usd_pinning_rootless_file_path:
            self.log.info("No USD or USD pinning file found, skipping.")
            return

        # get the full path of the usd file
        usd_file_path = Path(
            anatomy.fill_root(usd_file_rootless_path))
        usd_pinning_path = Path(
            anatomy.fill_root(usd_pinning_rootless_file_path))

        generate_pinning_file(
            usd_file_path.as_posix(),
            ayon_api.get_project_roots_for_site(get_current_project_name()),
            usd_pinning_path.as_posix())



